// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: academictoken/subject/check_messages.proto

package types

import (
	fmt "fmt"
	proto "github.com/cosmos/gogoproto/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// SubjectWithPrerequisites combines subject content with its prerequisites
type SubjectWithPrerequisites struct {
	Subject            *SubjectContent      `protobuf:"bytes,1,opt,name=subject,proto3" json:"subject,omitempty"`
	PrerequisiteGroups []*PrerequisiteGroup `protobuf:"bytes,2,rep,name=prerequisite_groups,json=prerequisiteGroups,proto3" json:"prerequisite_groups,omitempty"`
}

func (m *SubjectWithPrerequisites) Reset()         { *m = SubjectWithPrerequisites{} }
func (m *SubjectWithPrerequisites) String() string { return proto.CompactTextString(m) }
func (*SubjectWithPrerequisites) ProtoMessage()    {}
func (*SubjectWithPrerequisites) Descriptor() ([]byte, []int) {
	return fileDescriptor_7e0c79451e43c64e, []int{0}
}
func (m *SubjectWithPrerequisites) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SubjectWithPrerequisites) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SubjectWithPrerequisites.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SubjectWithPrerequisites) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SubjectWithPrerequisites.Merge(m, src)
}
func (m *SubjectWithPrerequisites) XXX_Size() int {
	return m.Size()
}
func (m *SubjectWithPrerequisites) XXX_DiscardUnknown() {
	xxx_messageInfo_SubjectWithPrerequisites.DiscardUnknown(m)
}

var xxx_messageInfo_SubjectWithPrerequisites proto.InternalMessageInfo

func (m *SubjectWithPrerequisites) GetSubject() *SubjectContent {
	if m != nil {
		return m.Subject
	}
	return nil
}

func (m *SubjectWithPrerequisites) GetPrerequisiteGroups() []*PrerequisiteGroup {
	if m != nil {
		return m.PrerequisiteGroups
	}
	return nil
}

// CheckPrerequisitesMsg is the message to check if a student meets prerequisites
type CheckPrerequisitesMsg struct {
	StudentId string `protobuf:"bytes,1,opt,name=student_id,json=studentId,proto3" json:"student_id,omitempty"`
	SubjectId string `protobuf:"bytes,2,opt,name=subject_id,json=subjectId,proto3" json:"subject_id,omitempty"`
}

func (m *CheckPrerequisitesMsg) Reset()         { *m = CheckPrerequisitesMsg{} }
func (m *CheckPrerequisitesMsg) String() string { return proto.CompactTextString(m) }
func (*CheckPrerequisitesMsg) ProtoMessage()    {}
func (*CheckPrerequisitesMsg) Descriptor() ([]byte, []int) {
	return fileDescriptor_7e0c79451e43c64e, []int{1}
}
func (m *CheckPrerequisitesMsg) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CheckPrerequisitesMsg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CheckPrerequisitesMsg.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CheckPrerequisitesMsg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CheckPrerequisitesMsg.Merge(m, src)
}
func (m *CheckPrerequisitesMsg) XXX_Size() int {
	return m.Size()
}
func (m *CheckPrerequisitesMsg) XXX_DiscardUnknown() {
	xxx_messageInfo_CheckPrerequisitesMsg.DiscardUnknown(m)
}

var xxx_messageInfo_CheckPrerequisitesMsg proto.InternalMessageInfo

func (m *CheckPrerequisitesMsg) GetStudentId() string {
	if m != nil {
		return m.StudentId
	}
	return ""
}

func (m *CheckPrerequisitesMsg) GetSubjectId() string {
	if m != nil {
		return m.SubjectId
	}
	return ""
}

// PrerequisiteCheckResponse is the response from checking prerequisites
type PrerequisiteCheckResponse struct {
	IsEligible           bool     `protobuf:"varint,1,opt,name=is_eligible,json=isEligible,proto3" json:"is_eligible,omitempty"`
	MissingPrerequisites []string `protobuf:"bytes,2,rep,name=missing_prerequisites,json=missingPrerequisites,proto3" json:"missing_prerequisites,omitempty"`
}

func (m *PrerequisiteCheckResponse) Reset()         { *m = PrerequisiteCheckResponse{} }
func (m *PrerequisiteCheckResponse) String() string { return proto.CompactTextString(m) }
func (*PrerequisiteCheckResponse) ProtoMessage()    {}
func (*PrerequisiteCheckResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_7e0c79451e43c64e, []int{2}
}
func (m *PrerequisiteCheckResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PrerequisiteCheckResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PrerequisiteCheckResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PrerequisiteCheckResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PrerequisiteCheckResponse.Merge(m, src)
}
func (m *PrerequisiteCheckResponse) XXX_Size() int {
	return m.Size()
}
func (m *PrerequisiteCheckResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_PrerequisiteCheckResponse.DiscardUnknown(m)
}

var xxx_messageInfo_PrerequisiteCheckResponse proto.InternalMessageInfo

func (m *PrerequisiteCheckResponse) GetIsEligible() bool {
	if m != nil {
		return m.IsEligible
	}
	return false
}

func (m *PrerequisiteCheckResponse) GetMissingPrerequisites() []string {
	if m != nil {
		return m.MissingPrerequisites
	}
	return nil
}

// EquivalenceCheckMsg is the message to check equivalence between subjects
type EquivalenceCheckMsg struct {
	SourceSubjectId  string `protobuf:"bytes,1,opt,name=source_subject_id,json=sourceSubjectId,proto3" json:"source_subject_id,omitempty"`
	TargetSubjectId  string `protobuf:"bytes,2,opt,name=target_subject_id,json=targetSubjectId,proto3" json:"target_subject_id,omitempty"`
	ForceRecalculate bool   `protobuf:"varint,3,opt,name=force_recalculate,json=forceRecalculate,proto3" json:"force_recalculate,omitempty"`
}

func (m *EquivalenceCheckMsg) Reset()         { *m = EquivalenceCheckMsg{} }
func (m *EquivalenceCheckMsg) String() string { return proto.CompactTextString(m) }
func (*EquivalenceCheckMsg) ProtoMessage()    {}
func (*EquivalenceCheckMsg) Descriptor() ([]byte, []int) {
	return fileDescriptor_7e0c79451e43c64e, []int{3}
}
func (m *EquivalenceCheckMsg) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EquivalenceCheckMsg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EquivalenceCheckMsg.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EquivalenceCheckMsg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EquivalenceCheckMsg.Merge(m, src)
}
func (m *EquivalenceCheckMsg) XXX_Size() int {
	return m.Size()
}
func (m *EquivalenceCheckMsg) XXX_DiscardUnknown() {
	xxx_messageInfo_EquivalenceCheckMsg.DiscardUnknown(m)
}

var xxx_messageInfo_EquivalenceCheckMsg proto.InternalMessageInfo

func (m *EquivalenceCheckMsg) GetSourceSubjectId() string {
	if m != nil {
		return m.SourceSubjectId
	}
	return ""
}

func (m *EquivalenceCheckMsg) GetTargetSubjectId() string {
	if m != nil {
		return m.TargetSubjectId
	}
	return ""
}

func (m *EquivalenceCheckMsg) GetForceRecalculate() bool {
	if m != nil {
		return m.ForceRecalculate
	}
	return false
}

// EquivalenceResponse is the response from checking equivalence
type EquivalenceResponse struct {
	SourceSubjectId    string `protobuf:"bytes,1,opt,name=source_subject_id,json=sourceSubjectId,proto3" json:"source_subject_id,omitempty"`
	TargetSubjectId    string `protobuf:"bytes,2,opt,name=target_subject_id,json=targetSubjectId,proto3" json:"target_subject_id,omitempty"`
	EquivalencePercent uint64 `protobuf:"varint,3,opt,name=equivalence_percent,json=equivalencePercent,proto3" json:"equivalence_percent,omitempty"`
	Status             string `protobuf:"bytes,4,opt,name=status,proto3" json:"status,omitempty"`
	FromCache          bool   `protobuf:"varint,5,opt,name=from_cache,json=fromCache,proto3" json:"from_cache,omitempty"`
}

func (m *EquivalenceResponse) Reset()         { *m = EquivalenceResponse{} }
func (m *EquivalenceResponse) String() string { return proto.CompactTextString(m) }
func (*EquivalenceResponse) ProtoMessage()    {}
func (*EquivalenceResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_7e0c79451e43c64e, []int{4}
}
func (m *EquivalenceResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EquivalenceResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EquivalenceResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EquivalenceResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EquivalenceResponse.Merge(m, src)
}
func (m *EquivalenceResponse) XXX_Size() int {
	return m.Size()
}
func (m *EquivalenceResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_EquivalenceResponse.DiscardUnknown(m)
}

var xxx_messageInfo_EquivalenceResponse proto.InternalMessageInfo

func (m *EquivalenceResponse) GetSourceSubjectId() string {
	if m != nil {
		return m.SourceSubjectId
	}
	return ""
}

func (m *EquivalenceResponse) GetTargetSubjectId() string {
	if m != nil {
		return m.TargetSubjectId
	}
	return ""
}

func (m *EquivalenceResponse) GetEquivalencePercent() uint64 {
	if m != nil {
		return m.EquivalencePercent
	}
	return 0
}

func (m *EquivalenceResponse) GetStatus() string {
	if m != nil {
		return m.Status
	}
	return ""
}

func (m *EquivalenceResponse) GetFromCache() bool {
	if m != nil {
		return m.FromCache
	}
	return false
}

func init() {
	proto.RegisterType((*SubjectWithPrerequisites)(nil), "academictoken.subject.SubjectWithPrerequisites")
	proto.RegisterType((*CheckPrerequisitesMsg)(nil), "academictoken.subject.CheckPrerequisitesMsg")
	proto.RegisterType((*PrerequisiteCheckResponse)(nil), "academictoken.subject.PrerequisiteCheckResponse")
	proto.RegisterType((*EquivalenceCheckMsg)(nil), "academictoken.subject.EquivalenceCheckMsg")
	proto.RegisterType((*EquivalenceResponse)(nil), "academictoken.subject.EquivalenceResponse")
}

func init() {
	proto.RegisterFile("academictoken/subject/check_messages.proto", fileDescriptor_7e0c79451e43c64e)
}

var fileDescriptor_7e0c79451e43c64e = []byte{
	// 478 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x93, 0x41, 0x6b, 0x13, 0x41,
	0x18, 0x86, 0xb3, 0x6d, 0xad, 0x66, 0x72, 0xa8, 0xdd, 0x18, 0x59, 0x0b, 0x5d, 0xcb, 0x82, 0x10,
	0x5a, 0xd8, 0x40, 0x7b, 0xf0, 0x28, 0x18, 0x8a, 0xf4, 0x20, 0x94, 0x2d, 0x22, 0x7a, 0x19, 0x26,
	0xb3, 0x5f, 0x37, 0x63, 0x37, 0x3b, 0x9b, 0xf9, 0x66, 0x45, 0xff, 0x85, 0x67, 0x7f, 0x88, 0xbf,
	0xc1, 0x63, 0x2f, 0x82, 0x47, 0x49, 0xfe, 0x88, 0xec, 0xcc, 0xb4, 0xd9, 0xb5, 0xf1, 0xd8, 0x53,
	0xc8, 0xfb, 0xbe, 0xf3, 0x7e, 0xcf, 0x37, 0xcb, 0x90, 0x43, 0xc6, 0x59, 0x0a, 0x33, 0xc1, 0xb5,
	0xbc, 0x82, 0x62, 0x84, 0xd5, 0xe4, 0x13, 0x70, 0x3d, 0xe2, 0x53, 0xe0, 0x57, 0x74, 0x06, 0x88,
	0x2c, 0x03, 0x8c, 0x4b, 0x25, 0xb5, 0xf4, 0x07, 0xad, 0x6c, 0xec, 0xb2, 0x7b, 0x47, 0xeb, 0x2b,
	0xdc, 0x2f, 0xe5, 0xb2, 0xd0, 0x50, 0x68, 0xdb, 0xb1, 0x17, 0xaf, 0x0f, 0x97, 0x0a, 0x14, 0xcc,
	0x2b, 0x81, 0x42, 0x03, 0xcd, 0x94, 0xac, 0x4a, 0x9b, 0x8f, 0x7e, 0x78, 0x24, 0xb8, 0xb0, 0xa1,
	0xf7, 0x42, 0x4f, 0xcf, 0x1b, 0x39, 0xf4, 0x5f, 0x91, 0x87, 0xae, 0x20, 0xf0, 0x0e, 0xbc, 0x61,
	0xef, 0xf8, 0x45, 0xbc, 0x16, 0x31, 0x76, 0x0d, 0x63, 0x8b, 0x92, 0xdc, 0x9c, 0xf2, 0x3f, 0x90,
	0xfe, 0xdd, 0xc9, 0x18, 0x6c, 0x1c, 0x6c, 0x0e, 0x7b, 0xc7, 0xc3, 0xff, 0x94, 0x35, 0x19, 0xde,
	0xd4, 0x07, 0x12, 0xbf, 0xfc, 0x57, 0xc2, 0xe8, 0x1d, 0x19, 0x8c, 0xeb, 0x4b, 0x6c, 0x11, 0xbf,
	0xc5, 0xcc, 0xdf, 0x27, 0x04, 0x75, 0x95, 0x42, 0xa1, 0xa9, 0x48, 0x0d, 0x77, 0x37, 0xe9, 0x3a,
	0xe5, 0x2c, 0x35, 0xb6, 0xbb, 0x39, 0x91, 0x06, 0x1b, 0xce, 0xb6, 0xca, 0x59, 0x1a, 0xcd, 0xc9,
	0xb3, 0x66, 0xa3, 0x19, 0x91, 0x00, 0x96, 0xb2, 0x40, 0xf0, 0x9f, 0x93, 0x9e, 0x40, 0x0a, 0xb9,
	0xc8, 0xc4, 0x24, 0x07, 0xd3, 0xfd, 0x28, 0x21, 0x02, 0x4f, 0x9d, 0xe2, 0x9f, 0x90, 0xc1, 0x4c,
	0x20, 0x8a, 0x22, 0xa3, 0x4d, 0x64, 0xbb, 0x71, 0x37, 0x79, 0xe2, 0xcc, 0x16, 0x73, 0xf4, 0xdd,
	0x23, 0xfd, 0xd3, 0x79, 0x25, 0x3e, 0xb3, 0x1c, 0x0a, 0x6e, 0x47, 0xd6, 0x8b, 0x1c, 0x92, 0x5d,
	0x94, 0x95, 0xe2, 0x40, 0x1b, 0xc0, 0x76, 0x9f, 0x1d, 0x6b, 0x5c, 0xdc, 0x60, 0xd7, 0x59, 0xcd,
	0x54, 0x06, 0x9a, 0xde, 0x59, 0x6e, 0xc7, 0x1a, 0xab, 0xec, 0x11, 0xd9, 0xbd, 0x94, 0x75, 0xad,
	0x02, 0xce, 0x72, 0x5e, 0xe5, 0x4c, 0x43, 0xb0, 0x69, 0x76, 0x79, 0x6c, 0x8c, 0x64, 0xa5, 0x47,
	0xbf, 0xda, 0x70, 0xb7, 0x57, 0x71, 0x5f, 0x70, 0x23, 0xd2, 0x87, 0xd5, 0x38, 0x5a, 0x82, 0xe2,
	0x50, 0x68, 0x83, 0xb7, 0x95, 0xf8, 0x0d, 0xeb, 0xdc, 0x3a, 0xfe, 0x53, 0xb2, 0x8d, 0x9a, 0xe9,
	0x0a, 0x83, 0x2d, 0xd3, 0xe8, 0xfe, 0xd5, 0xdf, 0xf9, 0x52, 0xc9, 0x19, 0xe5, 0x8c, 0x4f, 0x21,
	0x78, 0x60, 0xd6, 0xeb, 0xd6, 0xca, 0xb8, 0x16, 0x5e, 0xbf, 0xfc, 0xb9, 0x08, 0xbd, 0xeb, 0x45,
	0xe8, 0xfd, 0x59, 0x84, 0xde, 0xb7, 0x65, 0xd8, 0xb9, 0x5e, 0x86, 0x9d, 0xdf, 0xcb, 0xb0, 0xf3,
	0x71, 0xbf, 0xfd, 0x82, 0xbe, 0xdc, 0xbe, 0x21, 0xfd, 0xb5, 0x04, 0x9c, 0x6c, 0x9b, 0x77, 0x73,
	0xf2, 0x37, 0x00, 0x00, 0xff, 0xff, 0x46, 0xc9, 0x04, 0x29, 0xd9, 0x03, 0x00, 0x00,
}

func (m *SubjectWithPrerequisites) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SubjectWithPrerequisites) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SubjectWithPrerequisites) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.PrerequisiteGroups) > 0 {
		for iNdEx := len(m.PrerequisiteGroups) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PrerequisiteGroups[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCheckMessages(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Subject != nil {
		{
			size, err := m.Subject.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCheckMessages(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CheckPrerequisitesMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CheckPrerequisitesMsg) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CheckPrerequisitesMsg) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SubjectId) > 0 {
		i -= len(m.SubjectId)
		copy(dAtA[i:], m.SubjectId)
		i = encodeVarintCheckMessages(dAtA, i, uint64(len(m.SubjectId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.StudentId) > 0 {
		i -= len(m.StudentId)
		copy(dAtA[i:], m.StudentId)
		i = encodeVarintCheckMessages(dAtA, i, uint64(len(m.StudentId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PrerequisiteCheckResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PrerequisiteCheckResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PrerequisiteCheckResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.MissingPrerequisites) > 0 {
		for iNdEx := len(m.MissingPrerequisites) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.MissingPrerequisites[iNdEx])
			copy(dAtA[i:], m.MissingPrerequisites[iNdEx])
			i = encodeVarintCheckMessages(dAtA, i, uint64(len(m.MissingPrerequisites[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.IsEligible {
		i--
		if m.IsEligible {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EquivalenceCheckMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EquivalenceCheckMsg) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EquivalenceCheckMsg) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ForceRecalculate {
		i--
		if m.ForceRecalculate {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.TargetSubjectId) > 0 {
		i -= len(m.TargetSubjectId)
		copy(dAtA[i:], m.TargetSubjectId)
		i = encodeVarintCheckMessages(dAtA, i, uint64(len(m.TargetSubjectId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.SourceSubjectId) > 0 {
		i -= len(m.SourceSubjectId)
		copy(dAtA[i:], m.SourceSubjectId)
		i = encodeVarintCheckMessages(dAtA, i, uint64(len(m.SourceSubjectId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EquivalenceResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EquivalenceResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EquivalenceResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.FromCache {
		i--
		if m.FromCache {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if len(m.Status) > 0 {
		i -= len(m.Status)
		copy(dAtA[i:], m.Status)
		i = encodeVarintCheckMessages(dAtA, i, uint64(len(m.Status)))
		i--
		dAtA[i] = 0x22
	}
	if m.EquivalencePercent != 0 {
		i = encodeVarintCheckMessages(dAtA, i, uint64(m.EquivalencePercent))
		i--
		dAtA[i] = 0x18
	}
	if len(m.TargetSubjectId) > 0 {
		i -= len(m.TargetSubjectId)
		copy(dAtA[i:], m.TargetSubjectId)
		i = encodeVarintCheckMessages(dAtA, i, uint64(len(m.TargetSubjectId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.SourceSubjectId) > 0 {
		i -= len(m.SourceSubjectId)
		copy(dAtA[i:], m.SourceSubjectId)
		i = encodeVarintCheckMessages(dAtA, i, uint64(len(m.SourceSubjectId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintCheckMessages(dAtA []byte, offset int, v uint64) int {
	offset -= sovCheckMessages(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *SubjectWithPrerequisites) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Subject != nil {
		l = m.Subject.Size()
		n += 1 + l + sovCheckMessages(uint64(l))
	}
	if len(m.PrerequisiteGroups) > 0 {
		for _, e := range m.PrerequisiteGroups {
			l = e.Size()
			n += 1 + l + sovCheckMessages(uint64(l))
		}
	}
	return n
}

func (m *CheckPrerequisitesMsg) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.StudentId)
	if l > 0 {
		n += 1 + l + sovCheckMessages(uint64(l))
	}
	l = len(m.SubjectId)
	if l > 0 {
		n += 1 + l + sovCheckMessages(uint64(l))
	}
	return n
}

func (m *PrerequisiteCheckResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IsEligible {
		n += 2
	}
	if len(m.MissingPrerequisites) > 0 {
		for _, s := range m.MissingPrerequisites {
			l = len(s)
			n += 1 + l + sovCheckMessages(uint64(l))
		}
	}
	return n
}

func (m *EquivalenceCheckMsg) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SourceSubjectId)
	if l > 0 {
		n += 1 + l + sovCheckMessages(uint64(l))
	}
	l = len(m.TargetSubjectId)
	if l > 0 {
		n += 1 + l + sovCheckMessages(uint64(l))
	}
	if m.ForceRecalculate {
		n += 2
	}
	return n
}

func (m *EquivalenceResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SourceSubjectId)
	if l > 0 {
		n += 1 + l + sovCheckMessages(uint64(l))
	}
	l = len(m.TargetSubjectId)
	if l > 0 {
		n += 1 + l + sovCheckMessages(uint64(l))
	}
	if m.EquivalencePercent != 0 {
		n += 1 + sovCheckMessages(uint64(m.EquivalencePercent))
	}
	l = len(m.Status)
	if l > 0 {
		n += 1 + l + sovCheckMessages(uint64(l))
	}
	if m.FromCache {
		n += 2
	}
	return n
}

func sovCheckMessages(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozCheckMessages(x uint64) (n int) {
	return sovCheckMessages(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *SubjectWithPrerequisites) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCheckMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SubjectWithPrerequisites: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SubjectWithPrerequisites: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subject", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCheckMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCheckMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCheckMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Subject == nil {
				m.Subject = &SubjectContent{}
			}
			if err := m.Subject.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrerequisiteGroups", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCheckMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCheckMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCheckMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PrerequisiteGroups = append(m.PrerequisiteGroups, &PrerequisiteGroup{})
			if err := m.PrerequisiteGroups[len(m.PrerequisiteGroups)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCheckMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCheckMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CheckPrerequisitesMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCheckMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CheckPrerequisitesMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CheckPrerequisitesMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StudentId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCheckMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCheckMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCheckMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StudentId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubjectId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCheckMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCheckMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCheckMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubjectId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCheckMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCheckMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PrerequisiteCheckResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCheckMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PrerequisiteCheckResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PrerequisiteCheckResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsEligible", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCheckMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsEligible = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MissingPrerequisites", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCheckMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCheckMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCheckMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MissingPrerequisites = append(m.MissingPrerequisites, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCheckMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCheckMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EquivalenceCheckMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCheckMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EquivalenceCheckMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EquivalenceCheckMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceSubjectId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCheckMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCheckMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCheckMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SourceSubjectId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetSubjectId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCheckMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCheckMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCheckMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TargetSubjectId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForceRecalculate", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCheckMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ForceRecalculate = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipCheckMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCheckMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EquivalenceResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCheckMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EquivalenceResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EquivalenceResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceSubjectId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCheckMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCheckMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCheckMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SourceSubjectId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetSubjectId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCheckMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCheckMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCheckMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TargetSubjectId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EquivalencePercent", wireType)
			}
			m.EquivalencePercent = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCheckMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EquivalencePercent |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCheckMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCheckMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCheckMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromCache", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCheckMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.FromCache = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipCheckMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCheckMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipCheckMessages(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowCheckMessages
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCheckMessages
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCheckMessages
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthCheckMessages
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupCheckMessages
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthCheckMessages
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthCheckMessages        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowCheckMessages          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupCheckMessages = fmt.Errorf("proto: unexpected end of group")
)
